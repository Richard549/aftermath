# Author: Andi Drebes <andi@drebesium.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as published
# by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301,
# USA.

from aftermath.util import enforce_type, enforce_type_list, enforce_type_tuple
import aftermath

class Tag(object):
    """Base class for code tags directing code generation through templates"""

    def setType(self, t):
        """Associates this tag with the type `t`"""

        self.__type = t

    def getType(self):
        # Dirty workaround: We don't want to set a default None value for
        # __type in the constructor, because otherwise all classes inheriting
        # from Tag would need to define their own constructor that calls the Tag
        # constructor.
        if hasattr(self, '_Tag__type'):
            return self.__type

class MultiTag(object):
    """Mixin for tags that can be associated more than once to a type"""
    pass

class TagWithSteps(Tag):
    """A base class for tags that implement an operation composed of multiple
    steps"""

    def __init__(self, steps = None):
        """`tag_steps` defines the steps that need to be carried out. This must
        be a list of instances of TagStep; steps are carried out in the order,
        in which they are specified in the list."""

        if steps:
            enforce_type_list(steps, TagStep)
            self.__steps = steps
        else:
            self.__steps = []

    def addStep(self, step):
        """Appends a step to be carried out after all steps previously added."""

        enforce_type(step, TagStep)
        self.__steps.append(step)

    def addSteps(self, *steps):
        """Appends a list of steps to be carried out after all steps previously
        added."""

        for step in steps:
            self.addStep(step)

    def getSteps(self):
        """Returns the list of all steps"""

        return self.__steps

class TagStep(object):
    """Base class for steps to be used with instances of TagWithSteps"""
    pass

class FunctionTagStep(TagStep):
    """Base class for TagSteps that consist in calling a function that is determined
    by a FunctionTag instance."""

    def __init__(self, ftag):
        """`ftag` must be a FunctionTag, representing the function that should
        be invoked for this step"""

        enforce_type(ftag, FunctionTag)
        self.__function_tag = ftag

    def getFunctionTag(self):
        """Returns the FunctionTag instance associated to the step"""

        return self.__function_tag

class FunctionTag(Tag):
    """Base class for tags that represent functions"""

    def __init__(self, function_name = None,
                 default_prefix = "",
                 default_suffix = ""):
        """If `function_name` is not None, this name is used verbatim as the
        name of the associated function. Otherwise, a function name is generated
        by concatenating `default_prefix`, the name of the type associated to the
        tag and `default_suffix`
        """

        enforce_type(default_prefix, str)
        enforce_type(default_suffix, str)
        enforce_type(function_name, [str, type(None)])

        self.__function_name = function_name
        self.__default_prefix = default_prefix
        self.__default_suffix = default_suffix

    def getFunctionName(self):
        """Returns the name of the function as a string"""

        if self.__function_name:
            return self.__function_name
        else:
            return self.getDefaultPrefix() + \
                self.getType().getName() + \
                self.getDefaultSuffix()

    def getDefaultSuffix(self):
        return self.__default_suffix

    def getDefaultPrefix(self):
        return self.__default_prefix

class GenerateFunctionTag(Tag):
    """Base class for tags indicating that a function is to be generated by a
    code generator"""
    pass

class TemplatedGenerateFunctionTag(GenerateFunctionTag):
    """Base class for tags generating functions from templates"""

    def __init__(self, template_type):
        """`template_type` must be a template class generating the code"""

        enforce_type(template_type, type)

        self.__template_type = template_type

    def instantiateTemplate(self):
        """Returns the class of the template generating the code of the
        function"""
        return self.__template_type(self.getType())

class Destructor(FunctionTag):
    """Base class for destructors"""

    def __init__(self, destructor_name = None,
                 takes_address = True,
                 *args, **kwargs):
        """
        `destructor_name`: a string indicating the name of the destructor.

        `takes_address`: if True the destructor takes the address of an instance
        of the type as an argument, otherwise it expects the value itself (e.g.,
        a types that aliases a pointer type might set takes_address to False,
        since the type itself already represents an address)."""

        super(Destructor, self).__init__(function_name = destructor_name,
                                         default_suffix = "_destroy")

        self.__destructor_name = destructor_name
        self.__takes_address = takes_address

    def takesAddress(self):
        return self.__takes_address

class GenerateDestructor(TemplatedGenerateFunctionTag):
    """Indicates that a destructor should be generated for the type"""

    def __init__(self):
        TemplatedGenerateFunctionTag.__init__(
            self,
            template_type = aftermath.templates.Destructor)

class DefaultConstructor(FunctionTag):
    """Base class for default constructors (without arguments)"""

    def __init__(self, constructor_name = None,
                 *args, **kwargs):
        """
        `constructor_name`: a string indicating the name of the constructor."""

        super(DefaultConstructor, self).__init__(
            function_name = constructor_name,
            default_suffix = "_default_init")

        self.__constructor_name = constructor_name

class GenerateDefaultConstructor(TemplatedGenerateFunctionTag, DefaultConstructor):
    """Indicates that a default constructor should be generated for the type"""

    def __init__(self, field_values = None):
        """`field_values` may be a list of pairs composed of field names and their
        initial value."""

        TemplatedGenerateFunctionTag.__init__(
            self,
            template_type = aftermath.templates.DefaultConstructor)
        DefaultConstructor.__init__(self)

        if field_values is None:
            self.__field_values = []
        else:
            self.__field_values = field_values

    def getFieldValues(self):
        return self.__field_values;

class Compound(Tag):
    """Base tag for classes defining compound types"""
    pass

class Packed(Tag):
    """Base tag indicating that a structure should be declared as packed (i.e.,
    without padding between its fields)"""
    pass
